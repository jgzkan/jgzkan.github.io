---
layout: post
title: "[심화세션]_4주차"
published: true
date: 2024-10-07
math: true
categories: 
tags: KHUDA 심화세션
---


## **주교재** ##

<br/>

## [7장] 물류 네트워크 최적 설계를 위한 테크닉 10 ##

<br/>

### 61. 운송 최적화 문제를 풀어보자 ###

``` python
# 초기 설정  #
np.random.seed(1)
nw = len(df_tc.index)
nf = len(df_tc.columns)
pr = list(product(range(nw), range(nf)))

# 수리 모델 작성 #

# 모델 생성
m1 = model_min()
# v1에 dict 형식으로 LpVariable 정의 -> 'v1_2' 이런 형식으로
v1 = {(i,j):LpVariable('v%d_%d'%(i,j),lowBound=0) for i,j in pr}

# 목적함수 정의 : (거래 비용 * 거래량)의 합
m1 += lpSum(df_tc.iloc[i][j]*v1[i,j] for i,j in pr)
for i in range(nw):
    m1 += lpSum(v1[i,j] for j in range(nf)) <= df_supply.iloc[0][i]
for j in range(nf):
    m1 += lpSum(v1[i,j] for i in range(nw)) >= df_demand.iloc[0][j]
# 최적화 문제 해결
m1.solve()

# 총 운송 비용 계산 #
df_tr_sol = df_tc.copy() # df_tr_sol에 df_tc 복사해서 저장
total_cost = 0
for k,x in v1.items():
    i,j = k[0],k[1]
    df_tr_sol.iloc[i][j] = value(x)
    total_cost += df_tc.iloc[i][j]*value(x)
    
print(df_tr_sol)
print("총 운송 비용:"+str(total_cost))
```

- LpVariable: Pulp, 결정변수 정의, 최적화 문제서 각 변수의 값을 어떻게 최적화할지 모델링
    - 주요 매개변수: name, lowBound, upBound, cat(카테고리, 'Continuous' or 'Integer')
- value(): Pulp, 선형 계획 문제서 최적화된 변수의 값 추출, solve로 해결한 뒤에 호출
- df.iloc[row_index, column_index]: pandas, 위치 기반 인덱싱, 필터링 불가, 순차적 접근 시에 유용
- df.loc[row_label, column_label]: pandas, 레이블 기반 인덱싱, 필터링 가능, 이름으로 접근해야할 때 유용

<br/>

### 62. 최적 운송 경로를 네트워크로 확인하자 ###

```python
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import networkx as nx

# 데이터 불러오기
df_tr = df_tr_sol.copy()
df_pos = pd.read_csv('trans_route_pos.csv')

# 객체 생성
G = nx.Graph()

# 노드 설정: df의 모든 칼럼에 대해 노드 설정
for i in range(len(df_pos.columns)):
    G.add_node(df_pos.columns[i])

# 엣지 설정 & 엣지의 가중치 리스트화
num_pre = 0
edge_weights = []
size = 0.1 # 가중치 스케일 조절(엣지 두께 조절)
for i in range(len(df_pos.columns)):
    for j in range(len(df_pos.columns)):
        # 자기 자신으로 이어지는 것이 아니면 엣지 추가함: 가능한 모든 경우의 엣지 생성
        if not (i==j):
            # 엣지 추가
            G.add_edge(df_pos.columns[i],df_pos.columns[j])
            # 엣지 가중치 추가
            if num_pre<len(G.edges):
                num_pre = len(G.edges)
                weight = 0

                # if문이 True면(0만 아니면), 이어지는 코드 블럭 실행, df가 대칭이 아닐 경우에 대비해 elif문에서 i, j 위치를 바꾸어 한번 더 실행 
                if (df_pos.columns[i] in df_tr.columns)and(df_pos.columns[j] in df_tr.index):
                    if df_tr[df_pos.columns[i]][df_pos.columns[j]]:
                        weight = df_tr[df_pos.columns[i]][df_pos.columns[j]]*size
                elif(df_pos.columns[j] in df_tr.columns)and(df_pos.columns[i] in df_tr.index):
                    if df_tr[df_pos.columns[j]][df_pos.columns[i]]:
                        weight = df_tr[df_pos.columns[j]][df_pos.columns[i]]*size
                edge_weights.append(weight)
                

# 좌표 설정
pos = {}
for i in range(len(df_pos.columns)):
    node = df_pos.columns[i]
    pos[node] = (df_pos[node][0],df_pos[node][1])
    
# 그리기
nx.draw(G, pos, with_labels=True,font_size=16, node_size = 1000, node_color='k', font_color='w', width=edge_weights)

# 표시
plt.show()
```

- G.add_node(n): 노드 n을 그래프에 추가
- G.add_edge(u,v): u와 v 사이에 엣지를 추가

<br/>


### 63. 최적운송경로가 제약조건을 만족하는지 확인하자 ###

```python
# 제약조건 계산함수
# 수요측
def condition_demand(df_tr,df_demand):
    # 모든 요소 0으로 설정
    flag = np.zeros(len(df_demand.columns))
    for i in range(len(df_demand.columns)):
        temp_sum = sum(df_tr[df_demand.columns[i]])
        # df_tr의 수요합이 df_demand의 수요량보다 크면 flag = 1 설정
        if (temp_sum>=df_demand.iloc[0][i]):
            flag[i] = 1
    return flag
            
# 공급측
def condition_supply(df_tr,df_supply):
    # 모든 요소 0으로 설정
    flag = np.zeros(len(df_supply.columns))
    for i in range(len(df_supply.columns)):
        temp_sum = sum(df_tr.loc[df_supply.columns[i]])
        # df_tr의 공급합이 df_supply의 공급량보다 적으면 flag = 1 설정
        if temp_sum<=df_supply.iloc[0][i]:
            flag[i] = 1
    return flag

print("수요 조건 계산 결과:"+str(condition_demand(df_tr_sol,df_demand)))
print("공급 조건 계산 결과:"+str(condition_supply(df_tr_sol,df_supply)))

# 수요 조건 계산 결과:[1. 1. 1. 1.]
# 공급 조건 계산 결과:[1. 1. 1.]
```

<br/>

### 64. 생산계획 데이터를 불러오자 ###

지금까지는 운송 비용 최적화를 계산했다. 
이제부턴 생산 계획 최적화를 계산해보자. 

<br/>

### 65. 이익을 계산하는 함수를 만들자 ###

> 생산계획 최적화
1. 목적함수, 제약 조건 정의
2. 제약 조건 아래서 목적함수 최소(대)화 변수 조합 찾기

```python
# 이익 계산 함수
def product_plan(df_profit,df_plan):
    profit = 0
    for i in range(len(df_profit.index)):
        for j in range(len(df_plan.columns)):
            profit += df_profit.iloc[i][j]*df_plan.iloc[i][j]
    return profit

print("총 이익:"+str(product_plan(df_profit,df_plan)))
```

<br/>

### 66. 생산최적화 문제를 풀어보자 ###

```python
import pandas as pd
from pulp import LpVariable, lpSum, value
from ortoolpy import model_max, addvars, addvals


df = df_material.copy()
inv = df_stock

m = model_max()
v1 = {(i):LpVariable('v%d'%(i),lowBound=0) for i in range(len(df_profit))}
m += lpSum(df_profit.iloc[i]*v1[i] for i in range(len(df_profit)))
for i in range(len(df_material.columns)):
    m += lpSum(df_material.iloc[j,i]*v1[j] for j in range(len(df_profit)) ) <= df_stock.iloc[:,i]
m.solve()

df_plan_sol = df_plan.copy()
for k,x in v1.items():
    df_plan_sol.iloc[k] = value(x)
print(df_plan_sol)
print("총 이익:"+str(value(m.objective)))
```

<br/>

### 67. 최적생산계획이 제약조건을 만족하는지 확인하자 ###

**최적화 문제를 풀 때에 최적화 계산을 한 결과를 이해하지 않고 그대로 받아들여서는 안된다!**

```python
# 제약 조건 계산 함수
def condition_stock(df_plan,df_material,df_stock):
    flag = np.zeros(len(df_material.columns))
    for i in range(len(df_material.columns)):  
        temp_sum = 0
        for j in range(len(df_material.index)):  
            temp_sum = temp_sum + df_material.iloc[j][i]*float(df_plan.iloc[j])
        if (temp_sum<=float(df_stock.iloc[0][i])):
            flag[i] = 1
        print(df_material.columns[i]+"  사용량:"+str(temp_sum)+", 재고:"+str(float(df_stock.iloc[0][i])))
    return flag

print("제약 조건 계산 결과:"+str(condition_stock(df_plan_sol,df_material,df_stock)))
```

<br/>

### 68. 물류 네트워크 설계 문제를 풀어보자 ###

지금까지는 운송 경로와 생산 계획 최적화 문제를 따로 생각했으나 실제로는 이 둘을 **동시에** 고려해야 한다. 

목적함수를 '운송 비용+ 제조 비용'으로 정의하고,

제약조건은 각 대리점의 판매 수가 수요 수를 넘는 것으로 정의하자.

<br/>

```python
import numpy as np
import pandas as pd

# 각 변수들에 해당하는 리스트, 튜플 생성
제품 = list('AB')
대리점 = list('PQ')
공장 = list('XY')
레인 = (2,2)

# 운송비 #
tbdi = pd.DataFrame(((j,k) for j in 대리점 for k in 공장), columns=['대리점','공장'])
tbdi['운송비'] = [1,2,3,1]
print(tbdi)

# 수요 #
tbde = pd.DataFrame(((j,i) for j in 대리점 for i in 제품), columns=['대리점','제품'])
tbde['수요'] = [10,10,20,20]
print(tbde)

# 생산 #
tbfa = pd.DataFrame(((k,l,i,0,np.inf) for k,nl in zip (공장,레인) for l in range(nl) for i in 제품), 
                    columns=['공장','레인','제품','하한','상한'])
tbfa['생산비'] = [1,np.nan,np.nan,1,3,np.nan,5,3]
tbfa.dropna(inplace=True)
tbfa.loc[4,'상한']=10
print(tbfa)

from ortoolpy import logistics_network
# tbde, tbdi, tbfa를 입력으로 사용, 사용할 칼럼 이름 지정
# logistics_network()는 여러 개의 값을 반환하는데, 이 중에서 tbdi2만 관심 있으므로 나머지는 무시하기 위해, 두 번째 값만 사용하기 위해 ' _, tbdi2, _'로 표현하고 이름 짓기
_, tbdi2, _ = logistics_network(tbde, tbdi, tbfa,dep = "대리점", dem = "수요",fac = "공장",prd = "제품",tcs = "운송비",pcs = "생산비",lwb = "하한",upb = "상한")

print(tbfa)
print(tbdi2)
```

- zip(공장, 레인): 파이썬, 여러 리스트를 병렬로 묶어주기 위한 함수

예시:
```python
list1 = [1, 2, 3]
list2 = ['a', 'b', 'c']

zipped = zip(list1, list2)
print(list(zipped))
```

<br/>

### 69. 최적 네트워크의 운송비용과 그 내역을 계산하자 ###

```python
# 새로운 df형태로 지정
tbdi2 = tbdi2[["공장","대리점","운송비","제품","VarX","ValX"]]
tbdi2

trans_cost = 0
for i in range(len(tbdi2.index)):
    trans_cost += tbdi2["운송비"].iloc[i]*tbdi2["ValX"].iloc[i]
print("총 운송비:"+str(trans_cost))
```

<br/>

### 70. 최적네트워크의 생산비용과 그 내역을 계산하자 ###

```python
tbfa

product_cost = 0
for i in range(len(tbfa.index)):
    product_cost += tbfa["생산비"].iloc[i]*tbfa["ValY"].iloc[i]
print("총 생산비:"+str(product_cost))
```

<br/>

## [8장] 수치 시뮬레이션으로 소비자의 행동을 예측하는 테크닉 10 ##

<br/>

### 71. 인간관계 네트워크를 가시화해보자 ###

```python
import networkx as nx
import matplotlib.pyplot as plt

# 그래프 객체 생성
G = nx.Graph()

# 노드 설정
NUM = len(df_links.index)
for i in range(1,NUM+1):
    node_no = df_links.columns[i].strip("Node")
    G.add_node(str(node_no))

# 엣지 설정
for i in range(NUM):
    for j in range(NUM):
        node_name = "Node" + str(j)
        if df_links[node_name].iloc[i]==1:
            G.add_edge(str(i),str(j))
        
# 그리기
nx.draw_networkx(G,node_color="k", edge_color="k", font_color="w")
plt.show()
```

- nx.draw_networkx(): nx.draw()보다 복잡한 그래프 시각화 가능, 자동으로 연결이 많은 노드를 중심에 오도록 설정

<br/>

### 72. 입소문에 의한 정보 전파 모습을 가시화해보자 ###

```python
# 랜덤으로 연결여부 결정
def determine_link(percent):
    rand_val = np.random.rand()
    if rand_val<=percent:
        return 1
    else:
        return 0

# 노드가 active 상태이면, j와의 연결 활성화 결정
def simulate_percolation(num, list_active, percent_percolation):
    for i in range(num):
        if list_active[i]==1:
            for j in range(num):
                node_name = "Node" + str(j)
                if df_links[node_name].iloc[i]==1:
                    if determine_link(percent_percolation)==1:
                        list_active[j] = 1
    return list_active

percent_percolation = 0.1
T_NUM = 36
NUM = len(df_links.index)
list_active = np.zeros(NUM)
list_active[0] = 1

list_timeSeries = []
for t in range(T_NUM):
    list_active = simulate_percolation(NUM, list_active, percent_percolation)
    # list_active가 매 시간 단계에서 변경되기에 이전 상태를 보존하기 위해 .copy() 사용
    list_timeSeries.append(list_active.copy())

# 액티브 노드 가시화 #
def active_node_coloring(list_active):
    #print(list_timeSeries[t])
    list_color = []
    for i in range(len(list_timeSeries[t])):
        if list_timeSeries[t][i]==1:
            list_color.append("r")
        else:
            list_color.append("k")
    #print(len(list_color))
    return list_color

# 그리기
t = 0
nx.draw_networkx(G,font_color="w",node_color=active_node_coloring(list_timeSeries[t]))
plt.show()
```
t=11,35로 가시화해보면, 12개월까지는 완만한 전파였지만, 오랜 시간이 흐른 뒤 거의 전원에게 전파되는 모습을 볼 수 있다. 

![img1](assets/img/DBRS_week4/img1.png)
![img2](assets/img/DBRS_week4/img2.png)
![img3](assets/img/DBRS_week4/img3.png)

<br/>

### 73. 입소문 수의 시계열 변화를 그래프화 해보자 ###

```python
# 시계열 그래프 그리기
list_timeSeries_num = []
# list_timeSeries는 percolation함수에서 노드 활성 시간을 저장한 리스트
for i in range(len(list_timeSeries)):
    list_timeSeries_num.append(sum(list_timeSeries[i]))

plt.plot(list_timeSeries_num)
plt.show()
```
![img4](assets/img/DBRS_week4/img4.png)


<br/>

### 74. 회원수의 시계열 변화를 시뮬레이션해보자 ###


```python
def simulate_population(num, list_active, percent_percolation, percent_disapparence,df_links):
    # 확산 #
    for i in range(num):
        if list_active[i]==1:
            for j in range(num):
                if df_links.iloc[i][j]==1:
                    if determine_link(percent_percolation)==1:
                        list_active[j] = 1
    # 소멸 #
    for i in range(num):
        if determine_link(percent_disapparence)==1:
            list_active[i] = 0
    return list_active

percent_percolation = 0.1
percent_disapparence = 0.05
T_NUM = 100
NUM = len(df_links.index)
list_active = np.zeros(NUM)
list_active[0] = 1

list_timeSeries = []
for t in range(T_NUM):
    list_active = simulate_population(NUM, list_active, percent_percolation, percent_disapparence,df_links)
    list_timeSeries.append(list_active.copy())

# 시계열 그래프 그리기
list_timeSeries_num = []
for i in range(len(list_timeSeries)):
    list_timeSeries_num.append(sum(list_timeSeries[i]))

plt.plot(list_timeSeries_num)
plt.show()
```
![img6](assets/img/DBRS_week4/img6.png)

```python
percent_disapparence = 0.2
list_active = np.zeros(NUM)
list_active[0] = 1
list_timeSeries = []
for t in range(T_NUM):
    list_active = simulate_population(NUM, list_active, percent_percolation, percent_disapparence,df_links)
    list_timeSeries.append(list_active.copy())

# 시계열 그래프 그리기
list_timeSeries_num = []
for i in range(len(list_timeSeries)):
    list_timeSeries_num.append(sum(list_timeSeries[i]))

plt.plot(list_timeSeries_num)
plt.show()
```
![img5](assets/img/DBRS_week4/img5.png)

<br/>

### 75. 파라미터 전체를 '상관관계'를 보면서 파악해보자 ###

```python
# 상관관계 계산
print("상관관계 계산시작")
T_NUM = 100
NUM_PhaseDiagram = 20
phaseDiagram = np.zeros((NUM_PhaseDiagram,NUM_PhaseDiagram))
for i_p in range(NUM_PhaseDiagram):
    for i_d in range(NUM_PhaseDiagram):
        percent_percolation = 0.05*i_p
        percent_disapparence = 0.05*i_d
        list_active = np.zeros(NUM)
        list_active[0] = 1
        for t in range(T_NUM):
            list_active = simulate_population(NUM, list_active, percent_percolation, percent_disapparence,df_links)
        phaseDiagram[i_p][i_d] = sum(list_active)
print(phaseDiagram)

# 표시
# phaseDiagram 배열을 히트맵으로 표시
plt.matshow(phaseDiagram)
# 색상 막대 속성 표시, 크기 조절
plt.colorbar(shrink=0.8)
plt.xlabel('percent_disapparence')
plt.ylabel('percent_percolation')
# 눈금 위치, 레이블 설정
plt.xticks(np.arange(0.0, 20.0,5), np.arange(0.0, 1.0, 0.25))
plt.yticks(np.arange(0.0, 20.0,5), np.arange(0.0, 1.0, 0.25))
# 축의 눈금 표시 비활성화
plt.tick_params(bottom=False,
                left=False,
                right=False,
                top=False)
plt.show()
```
![img7](assets/img/DBRS_week4/img7.png)

<br/>

### 76. 실제 데이터를 불러와보자 ###

```python
import pandas as pd

df_mem_links = pd.read_csv("links_members.csv")
df_mem_info = pd.read_csv("info_members.csv")
df_mem_links
```

<br/>

### 77. 링크 수의 분포를 가시화해보자 ###

> 네트워크의 구조
- 스몰 월드형: 몇 안 되는 스텝으로 전원이 연결됨
- 스케일 프리형: 소수의 연결을 많이 가지는 사람이 허브가 되

```python
NUM = len(df_mem_links.index)
array_linkNum = np.zeros(NUM)
for i in range(NUM):
    array_linkNum[i] = sum(df_mem_links["Node"+str(i)])

plt.hist(array_linkNum, bins=10,range=(0,250))
plt.show()
```
![img8](assets/img/DBRS_week4/img8.png)

정규분포와 유사한 형태의 히스토그램을 나타내는 것을 볼 수 있다. 

스케일프리형이라면 이 분포가 '멱 법칙'에 가까워지며, 링크를 많이 가진 허브가 작동하지 않으면(입소문을 퍼뜨리지 않으면) 입소문이 중간에 퍼지지 않는 특징을 가지고 있다. 

그러나 이 분포는 거의 모든 노드가 어느 정도의 링크 수를 가지고 있기에 '급격히 입소문이 퍼지지 않는' 대신에 '허브에 의존하지 않고 입소문이 퍼지기 쉽다'라고 할 수 있다. 

<br/>

### 78. 시뮬레이션을 위해 실제 데이터로부터 파라미터를 추정하자 ###

```python
NUM = len(df_mem_info.index)
# 첫 번째 열은 노드 이름이기에 -1 수행
T_NUM = len(df_mem_info.columns)-1
# 소멸 확률 추정 #
count_active = 0
count_active_to_inactive = 0
for t in range(1,T_NUM):
    for i in range(NUM):
        if (df_mem_info.iloc[i][t]==1):
            count_active_to_inactive += 1
            # 첫 번째 열을 빼고 시작해서 t+1로 시행
            if (df_mem_info.iloc[i][t+1]==0):
                count_active += 1
estimated_percent_disapparence = count_active/count_active_to_inactive

# 확산 확률 추정: 어렵다.. #
count_link = 0
count_link_to_active = 0
count_link_temp = 0
for t in range(T_NUM-1):
    df_link_t = df_mem_info[df_mem_info[str(t)]==1]
    temp_flag_count = np.zeros(NUM)
    for i in range(len(df_link_t.index)):
        df_link_temp = df_mem_links[df_mem_links["Node"+str(df_link_t.index[i])]==1]
        for j in range(len(df_link_temp.index)):
            if (df_mem_info.iloc[df_link_temp.index[j]][t]==0):
                if (temp_flag_count[df_link_temp.index[j]]==0):
                    count_link += 1
                if (df_mem_info.iloc[df_link_temp.index[j]][t+1]==1):
                    if (temp_flag_count[df_link_temp.index[j]]==0):
                        temp_flag_count[df_link_temp.index[j]] = 1 
                        count_link_to_active += 1
estimated_percent_percolation = count_link_to_active/count_link

estimated_percent_disapparence
# 0.10147163541419416

estimated_percent_percolation
# 0.025184661323275185
```

<br/>

### 79. 실제 데이터와 시뮬레이션을 비교하자 ###

```python
percent_percolation = 0.025184661323275185
percent_disapparence = 0.10147163541419416
T_NUM = 24
NUM = len(df_mem_links.index)
list_active = np.zeros(NUM)
list_active[0] = 1
list_timeSeries = []
for t in range(T_NUM):
    list_active = simulate_population(NUM, list_active, percent_percolation, percent_disapparence,df_mem_links)
    list_timeSeries.append(list_active.copy())

list_timeSeries_num = []
for i in range(len(list_timeSeries)):
    list_timeSeries_num.append(sum(list_timeSeries[i]))

T_NUM = len(df_mem_info.columns)-1
list_timeSeries_num_real = []
for t in range(0,T_NUM):
    list_timeSeries_num_real.append(len(df_mem_info[df_mem_info[str(t)]==1].index))

plt.plot(list_timeSeries_num, label = 'simulated')
plt.plot(list_timeSeries_num_real, label = 'real')
plt.xlabel('month')
plt.ylabel('population')
plt.legend(loc='lower right')
plt.show()
```
![img9](assets/img/DBRS_week4/img9.png)

<br/>

### 80. 시뮬레이션으로 미래를 예측해보자 ###

```python
percent_percolation = 0.025184661323275185
percent_disapparence = 0.10147163541419416
T_NUM = 36
NUM = len(df_mem_links.index)
list_active = np.zeros(NUM)
list_active[0] = 1
list_timeSeries = []
for t in range(T_NUM):
    list_active = simulate_population(NUM, list_active, percent_percolation, percent_disapparence,df_mem_links)
    list_timeSeries.append(list_active.copy())

list_timeSeries_num = []
for i in range(len(list_timeSeries)):
    list_timeSeries_num.append(sum(list_timeSeries[i]))

plt.plot(list_timeSeries_num, label = 'simulated')
plt.xlabel('month')
plt.ylabel('population')
plt.legend(loc='lower right')
plt.show()
```
![img10](assets/img/DBRS_week4/img10.png)


<br/>
<br/>
<br/>


## 부교재 ##

<br/>



###




























































































