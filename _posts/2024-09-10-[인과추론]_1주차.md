---
layout: post
title: "[인과추론]_1주차"
published: true
date: 2024-09-10
math: true
categories: 
tags: KHUDA 인과추론
---

## 구성 ## 

교재: <실무로 통하는 인과추론 with.파이썬>

기본적으로 머신러닝, 통계, 파이썬 프로그래밍에 대한 일정 수준의 사전 진식이 있다고 가정하고 설명한다.

> 1부: 인과추론의 기본 개념
- 1장: 가격 인하가 미치는 영향을 분석하는 데 필요한 인과추론의 주요 개념
- 2장: A/B 테스트의 중요성
- 3장: 인과관계 식별과 그래프 모델 (이론 중점)

> 2부: 선형회귀 분석과 성향점수 가중치 (인과관계-상관관계 구분에 중요)
- 4장: 선형회귀 분석, 직교화에 초점
- 5장: 성향점수와 강건 추정법

> 3부: 머신러닝과 빅데이터를 이용해 2부 내용 확장, 개인화된 의사결정 도구로의 인과추론 활용법
- 6장: 처치효과의 다양성
- 7장: 머신러닝과 인과추론이 만나면서 나타난 최근의 발전상 탐구

> 4부: 인과추론에 시간 차원 추가
- 8장: 이중차분법
- 9장: 마케팅 캠페인 영향 분석에 사용하는 통제집단합성법

> 5부: 랜덤화가 어려운 상황에서 활용할 수 있는 다양한 실험 설계 방법
- 10장: 지역 실험, 실험군-대조군 지역 선정법, 스위치백 실험 진행법
- 11장: 불응이 존재하는 실험, 도구 변수 사용법과 불연속 설계

<br/>

# 1부: 인과추론 기초 #

## [1장] 인과추론 소개 ##

통계적으로 '연관관계는 인과관계가 아니다' 라는 말을 자주 들었겠지만, **연관관계는 때로 인과관계가 될 수도 있다**

- 연관관계: 두 개의 수치나 확률변수(random variable)가 같이 움직이는 것
- 인과관계: 한 변수의 변화가 다른 변수의 변화를 일으키는 것


### [1.2] 인과추론의 목적 ###

인과추론의 유일한 목적: 현실 이해 but, 의사결정의 기준을 제시하는 것과 같은 규범적 요소가 자주 포함됨

일반적으로 원인과 결과의 관계를 알아야만 원인에 개입하여 원하는 결과를 가져올 수 있다. 


### [1.3] 머신러닝과 인과추론 ###

인과추론으로 답을 얻으려는 질문의 유형은 대부분 '만약(what if)' 유형이다. 
ML은 이러한 유형의 질문에 취약하다. ML을 잘 활용하려면 문제를 예측 문제로 구성해야 한다. 
하지만 아쉽게도 ML은 만병통치약이 아니다.
까다롭게 정해진 범주 내에서 엄청난 성능을 발휘할 수 있지만, 데이터가 모델에 적합된 것에서 조금만 달라져도 제대로 작동하지 않는다. 
이렇게 ML은 변수 간의 **연관관계**를 이용해 변수들을 다른 변수에서 예측한다. 
예측에 사용하는 변수를 변경하지 않는 한 ML은 매우 잘 작동한다. 
하지만 개입이 동반되는 대부분의 의사결정에서, 예측 모델로 목적을 달성하기는 매우 어렵다. 

하지만 ML을 단순한 예측 도구가 아닌 강력한 모델의 도구 상자라는 각도에서 접근하면 인과추론의 목표에 어떻게 연결되는지 이해할 것이다. 
3부에서 ML과 인과추론을 함께 사용하는 내용에 대해 다룰 예정.


### [1.4] 연관관계와 인과관계 ###

연관관계가 인과관계를 의미하지 않는다는 것은 직관적으로 이해할 수 있다. 

예를 들어, e-commerce 기업을 운영한다고 가정하자. 이때 가격할인이 판매량에 미치는 영향을 파악해야, 더 많이 판매해 얻는 이익이 더 저렴하게 판매해 얻는 손실을 상쇄하는 때를 알 수 있다. 그러면 언제 가격 할인을 하는 것이 좋다는 의사결정을 할 수 있다. 
 
!['img1'](asssets/img/CI_week1/img1.png)

> NOTE: 인과추론 연구에서 분석단위는 일반적으로 개입하려는 대상이다. 분석단위는 대부분 사람이지만 이번 장에서는 회사다.


#### [1.4.1] 처치와 결과 ####

여기서 처치(treatment)는 구하려는 효과에 대한 개입을 나타내는 용어다. 

T는 실험 대상의 처치여부를 나타낸다. 

위의 예시에서 처치는 온라인 플랫폼 내 기업 중 하나의 가격할인(is_on_sale)을 말한다.

> 처치는 T 대신 D로 표기하기도 한다. D는 인과적인 문제에 시간 차원이 포함될 때 혼동을 피하기 위해 사용하는 표기법이다. 

영향을 주려는 변수인 주간 판매량(weekly_amount_sold)은 결과라고 부르자. 

실험 대상의 결과는 Y로 표기하자. 

'처치'와 '결과'라는 두 개념을 사용하여 인과추론의 목표를 재정의하자면, T가 Y에 미치는 영향을 학습하는 과정이라고 볼 수 있다. 


#### [1.4.2] 인과추론의 근본적인 문제 ####

- 인과추론의 근본적인 문제: 동일한 실험 대상이 '처치'를 받은 상태와 받지 않은 상태를 동시에 관측할 수 없다는 것

위의 예시에서 처치와 결과를 그래프로 그려보자. 

!['img2'](asssets/img/CI_week1/img2.png)

이 그래프를 보면 상품 가격을 낮춘 상점들의 판매량이 훨씬 더 많았음을 알 수 있다. 

이는 우리의 직관과도 일치한다. 하지만 이토록 판매율이 급증하는 부분에서 도메인 지식을 바탕으로 주의를 기울여야 한다. 

판매량이 많게 나타난 이유는 상품을 가장 많이 판매하는 대기업들이 더 공격적으로 가격을 낮출 여유가 있기 때문일 수 있다. 또는 고객들이 가장 많이 구매하는 시기인 크리스마스쯤 할인을 진행한 영향일 수도 있다. 

여기서 중요한 부분은, 동일한 회사에서 할인이 진행되는 상황과 그렇지 않은 상황을 동시에 관측할 수 있어야만 가격할인이 판매량에 미치는 실제 효과를 확신할 수 있다는 점이다. 이러한 두 가지 **반사실**(counterfactual) 상황을 비교함으로써 가격할인 효과를 파악할 수 있다. 
그러나 앞서 설명했듯이 인과추론의 근본적인 문제는 동일 대상의 두 상황을 동시에 관측할 수 없다는 점이다. 

#### [1.4.3] 인과모델 ####

> Notation 
- 인과모델: 화살표(->)로 표시하는 일련의 할당 메커니즘이다. 이 메커니즘에서는 u를 사용해 모델 외부 변수를 나타낸다. 변수 u 이외의 다른 모든 변수는 매우 중요하므로 모델에 포함된다. 마지막으로, 한 변수를 다른 변수에 매핑하는 함수 f가 있다. 

!['img3'](asssets/img/CI_week1/img3.png)

두 번째 식에서 처치변수 T는 다른 변수 집합 u_y와 함께 함수 f_y를 통해 결과 Y를 유발한다. 
해당 수식에서 u_y는 결과가 단순히 처치변수만으로 결정되지 않음을 나타낸다. 

즉, 모델링하지 않기로 선택한 변수라 하더라도 결과에 영향을 미친다.

예시에 적용하면, 주간 판매량(weekly_amount_sold)은 처치에 해당하는 할인 여부(is_on_sale) 및 특정되지 않은 요인들인 u 때문에 발생한다. 변수 u의 목적은 모델에 포함된 변수로는 아직 설명되지 않은 변수의 모든 변동을 설명하는 것이다. 

이러한 변수는 내생변수(endogenous variable)라고도 한다. 

해당 예시에서는 가격할인이 모델 내에 없는 요인들 때문에 유발된다고 볼 수 있다. 

!['img4'](asssets/img/CI_week1/img4.png)

등호 대신 화살표를 사용하여 인과관계의 비가역성을 분명하게 표시했다. 
대수학과는 달리, 원인과 효과의 비가역성 때문에 인과모델을 다룰 때는 등호 주변으로 간단하게 변수를 옮길 수 없다는 점을 기억할 것.

더 많은 변수를 사용해서 모델링하려면 u에서 변수를 꺼내서 명시적으로 인과모델에 포함시키면 된다. 

예시에 적용하면, 이전 모델에는 BusinessSize가 포함되지 않았고, 해당 변수는 다른 변수들과 함께 u에 뭉뚱그려 포함되어 있었다. 하지만 다음과 같이 모델링할 수 있다. 

!['img5'](asssets/img/CI_week1/img5.png)

!['img6'](asssets/img/CI_week1/img6.png)

내생변수 IsOnSale과 BusinessSize가 선형적으로 결합한 결과로 AmountSold를 만드는 것을 알 수 있다. 

즉, 해당 **선형모델**은 이전 모델보다 더 많은 가정을 하며, 변수 간의 관계에 함수 형태를 부여한다고 볼 수 있다. 


#### [1.4.4] 개입 ####

!['img7'](asssets/img/CI_week1/img7.png)

대부분의 인과추론은 인과 추정량에 대한 이론적 표현에서 직접 관측할 수 없는 부분을 제거하기 위한 일련의 과정으로, 이를 식별(identification)이라고 부른다.

!['img8'](asssets/img/CI_week1/img8.png)


#### [1.4.5] 개별 처치효과 ####

do(.)연산자를 사용하면 개별 실험 대상 i에 처치가 결과에 미치는 영향인 개별처치효과(individual treatment effect, ITE)를 표현할 수 있다. 

!['img9'](asssets/img/CI_week1/img9.png)

인과추론의 근본적인 문제 때문에 앞의 식 중 한 가지 항에 대해서만 관측할 수 있다. 
따라서 이론적으로 해당 식을 표현할 수 있다고 해도, 반드시 데이터에서 이를 찾을 수 있다는 뜻은 아니다. 


#### [1.4.6] 잠재적 결과 ####

do(.) 연산자와 함께, 인과추론에서 가장 흥미롭고 널리 사용하는 개념인 반사실 또는 잠재적 결과도 정의 할 수 있다. 

!['img10'](asssets/img/CI_week1/img10.png)

!['img11'](asssets/img/CI_week1/img11.png)

!['img12'](asssets/img/CI_week1/img12.png)

> 인과추론에는 항상 가정이 동반된다. 가정은 데이터가 어떻게 생성되었는지에 관한 믿음을 표현할 때 사용한다. 일반적으로 가정은 데이터로 검증할 수 없기 때문에 필요하다. 


#### [1.4.7] 일치성 및 SUTVA ####

**첫 번째 가정: 잠재적 결과가 처치와 일치성이 있어야 한다.**
다시 말해, T로 지정된 처치 외에 숨겨진 여러 가지 형태의 처치는 존재하지 않는다.

**두 번째 가정: 상호 간섭 없음 또는 SUTVA.**
하나의 실험 대상에 대한 효과는 다른 실험 대상의 영향을 받지 않는다. 

> 가정 위배: 두 가지 가정 모두를 위배하는 경우를 다룰 수 있을 때가 많다. *일치성 가정* 위배를 해결하려면 분석 시 처치에 대한 모든 버전을 포함해야 한다. 또한, *파급 효과*를 처리하려면 다른 대상에서 발생하는 효과를 포함하도록 처치효과의 정의를 확장하고, 더 유연한 모델을 사용하여 처치효과를 추정할 수 있다. 

> SUTVA는 'stable unit of treatment value assumption'의 약어로, 이 가정은 한 실험 대상의 처치가 다른 대상의 결과에 영향을 미치면 안됨을 의미한다. 이 책에서는 SUTVA를 상호 간섭 없음(파급 효과 없음)의 의미로 활용하고 있지만, 엄밀하게는 두 가정을 모두 합한 것이 SUTVA다. 


#### [1.4.8] 인과 추정량 ####

인과추론의 근본적인 문제를 한 번 더 강조하면, **잠재적 결과 중 하난만 관측할 수 있으므로 개별 처치효과를 알 수 없다.**

비록 개별 효과를 알 수는 없지만 데이터에서 학습할 수 있는 3가지 인과 추정량을 알아보자. 

- 평균 처치효과(average treatment effect, ATE)를 세 방식으로 정의

!['img13'](asssets/img/CI_week1/img13.png)
!['img14'](asssets/img/CI_week1/img14.png)
!['img15'](asssets/img/CI_week1/img15.png)

평균 처치효과는 처치 T가 평균적으로 미치는 영향을 나타낸다. 실험 대상에 따라 더 많거나 적은 영향을 받을 수 있다. 개별 대상에 미치는 영향은 알 수 없다. 또한 데이터에서 ATE를 추정하고 싶다면 기댓값을 표본 평균으로 대체할 수도 있다. 

ATE를 추정하는 방법은 앞으로 배울 예정.

- 실험군에 대한 평균 처치효과(average treatment effect on the treated, ATT) 

!['img16'](asssets/img/CI_week1/img16.png)

이는 처치 받은 대상에 대한 처치효과다. 
여기서 동일한 처치에 대해 두 가지 잠재적 결과가 어떻게 정의되는지 알아두는 것이 중요하다. 
ATT는 처치 받은 대상을 조건으로 하므로 Y_0i는 항상 관측되지 않지만, 이론적으로는 잘 정의될 수 있다. 

- 조건부 평균 처치효과(conditional avearage treatment effect, CATE)

!['img17'](asssets/img/CI_week1/img17.png)

이는 변수 X로 정의된 그룹에서의 처치효과다. 
조건부 평균 처치효과는 어떤 유형의 실험 대상이 개입에 더 잘 반응하는지 알 수 있어서 개인화에 매우 유용하다. 
처치변수가 연속형일 때도 인과 추정량을 정의할 수 있다. 이 경우 차이를 편도함수로 대체한다. 


### [1.5] 편향 ###

**편향: 인과관계와 연관관계를 다르게 만드는 요소**

전반적인 문제는 데이터에서 추정하는 수치가 찾으려는 인과 추정량과 일치하지 않는다는 사실이다. 

앞 사례를 볼 때, 가격할인이 기업의 판매량을 높인다는 주장에 직면했을 때, 할인한 기업은 가격할인 없이도 어차피 더 많이 팔았을 것이라고 말함으로써 의문을 제기할 수 있다. 해당 기업들이 더 크고, 공격적으로 할인할 여유가 있기 때문이다. 
즉, 할인한 회사(실험군)와 할인하지 않은 회사(대조군)를 비교할 수 없다. 

!['img18'](asssets/img/CI_week1/img18.png)
!['img19'](asssets/img/CI_week1/img19.png)


#### [1.5.1] 편향의 수식적 이해 ####

!['img20'](asssets/img/CI_week1/img20.png)

이 편향식은 인과적 질문들에서 접하게 될 모든 문데를 포함한다. 

연관관계가 인과관계는 아닌 이유를 알려줍니다. 연관관계는 실험군에 대한 처치효과(ATT)에 편향을 더한 값과 같다. **편향은 처치와 관계없이 실험군과 대조군이 어떻게 다른지에 따라 주어지고, 이는 Y_0의 차이로 표현된다.  

이런 일이 발생하는 이유는 교란(confounding) 때문이다. 
관측할 수 없는 많은 요소가 처치와 함께 변화하므로 편향이 발생한다. 
예시에서는 결과적으로 실험군과 대조군이 할인 여부 외에도 규모, 위치 등 여러 가지 면에서 차이가 있다.
할인한 회사와 하지 않은 회사가 평균적으로 서로 비슷해야, **실험군과 대조군이 교환가능해야** 가격할인으로 판매량이 얼마나 증가하는지 결정할 수 있다. 

!['img21'](asssets/img/CI_week1/img21.png)


#### [1.5.2] 편향의 시각적 가이드 ####

!['img22'](asssets/img/CI_week1/img22.png)

위의 그래프를 보면 일반적으로 할인한 회사가 더 큰 규모의 회사임을 볼 수 있다.

이 편향은 심슨의 역설의 덜 극단적인 버전과 같다.

!['img23'](asssets/img/CI_week1/img23.png)

!['img24'](asssets/img/CI_week1/img24.png)

두 가지 잠재적 결과를 모두 그림에 추가했을 때의 결과와 비교해보자. (반사실적 결과는 삼각형)
!['img25'](asssets/img/CI_week1/img25.png)

오른쪽 그래프는 모든 실험 대상이 처치 받지 않도록 설정하여 편향을 나타낸 것이다. 처치가 없는 상태에서 실험군과 대조군에 차이가 있다면, 진정한 처치효과를 파악하기 어렵다. 



### [1.6] 인과효과 식별하기 ###

- 식별 과정: 관측 가능한 데이터에서 인과 추정량을 찾아내는 방법

인과적 식별은 편향을 없애는 과정으로도 볼 수 있다. 

실험군과 대조군이 서로 교환 가능하다면 데이터에서 관측할 수 있는 수치로 인과관계를 표현하는 일이 아주 간단해진다. 


#### [1.6.1] 독립성 가정 ####

독립성 가정은 E[Y_0|T] = E[Y_0], 즉 처치가 잠재적 결과에 *어떠한 정보도 제공하지 않음*을 의미한다. 

다시 말해, 처치 여부에 관계없이 실험군과 대조군 모두 서로 비교 가능하고 구별할 수 없다는 뜻이다.


#### [1.6.2] 랜덤화와 식별 ####

인과추론 문제는 보통 다음과 같이 두 단계로 나뉜다. 

1. 식별: 관측 가능한 데이터로 인과 추정량을 표현하는 방법을 알아내는 단계
2. 추정: 실제로 데이터를 사용하여 앞서 식별한 인과 추정량을 추정하는 단계

!['img26'](asssets/img/CI_week1/img26.png)

랜덤화에서는 처치 배정 메커니즘이 완전히 알려졌으므로 앞의 인과모델에서 외부변수 u_t가 사라졌다. 
게다가 실험 대상에 처치가 무작위로 이루어지므로 잠재적 결과는 물론이고 어떤 변수와도 독립적이게 된다. 랜덤화는 독립성 가정을 거의 강제적으로 만족하게 한다. 

!['img27'](asssets/img/CI_week1/img27.png)

- 평균 인과효과: 실험군과 대조군 사이에, 처치 이외에 다른 차이를 발생시키는 요인이 없다. 

- 인과적 식별: 편향을 제거하고 실험군과 대조군을 비교할 수 있게 만드는 현명한 방법을 찾아내서 눈에 보이는 모든 차이를 처치에 따른 효과로 돌리도록 하는 과정이다. 

- 식별: 데이터 생성 과정을 알거나 기꺼이 가정할 수 있는 경우에만 가능하다. 

데이터 자체도 인과효과 추정에 매우 중요하지만, 데이터(특히 처치)가 어떻게 이루어졌는지에 관한 설명도 중요하다. 


<br/>

## [2장] 무작위 실험 및 기초 통계 리뷰 ##

### [2.1] 무작위 배정으로 독립성 확보하기 ###

**연관관계는 ATT와 편향의 합으로 설명할 수 있다. 따라서 편향이 0이면, 측정한 연관관계는 오롯이 인과관계라고 볼 수 있다.** 

즉, 실험군과 대조군에서 처치 이외의 나머지 조건이 동일(비교 가능)하다면 연관관계는 인과관계가 된다. 

처치와 결과 사이의 독립성이 아닌, 잠재적 결과가 처치와 독립적이길 바란다. 

교차 판매 이메일의 영향을 파악하는 데 무작위 통제 실험을 활용해보자.


### [2.2] A/B 테스트 사례 ###

추천하는 제품을 고객이 구매했을 때, 이를 '전환'되었다고 한다. 

마케팅 팀은 애초에 전환 가능성이 높다고 생각한 고객에게만 이메일을 보냈다. 

!['img28'](asssets/img/CI_week1/img28.png)

쉽게 말해, 실제 이메일을 받은 고객은 설령 이메일을 받지 않았더라도 다른 고객보다 더 많이 전환될 수 있다. 
따라서 *편향* 때문에 단순한 비교로는 교차 판매 이메일의 실제 인과효과를 추정할 수 없다. 
이 문제를 해결하려면 이메일을 받은 고객과 받지 않은 고객을 비교 가능하도록 만들어야 한다. 즉, E[Y_0|T=1] = E[Y_0|T=0]이다.

이메일을 무작위로 보내면 이메일을 받은 고객과 받지 않은 고객의 전환율은 평균적으로 동일해진다. 
실제로 무작위 배정했다고 가정하고 전체 고객에서 무작위로 세 고객을 샘플링해 각각 no email, long, short로 서로 다른 이메일을 보냈다. 

!['img29'](asssets/img/CI_week1/img29.png)

!['img30'](asssets/img/CI_week1/img30.png)

RCT의 장점은 마케팅팀이 전환 가능성이 높은 고객을 골랐는지를 걱정할 필요가 없다는 것이다. 
다시 말해, 실험군이 처치 받았다는 사실 외에 다른 차별점이 있는지 걱정할 필요가 없다는 뜻이다. 

그런데 나이를 보면 실험군은 매우 비슷해 보이지만, 성별에 차이가 있는 것으로 보인다. 

실험 대상 집단 사이의 정규화 차이를 계산해서 평가해보자. 
!['img31'](asssets/img/CI_week1/img31.png)

이 차이가 너무 작거나 크지 않은게 좋다. 명확한 임곗값은 없지만 경험적으로 0.5 정도가 적절하다. 

이 사례에서는 차이가 크지 않지만, 짧은 이메일을 받은 그룹의 성별 차이가 크고, 긴 이메일을 받은 그룹의 나이차가 큰 것으로 보인다. 



### [2.3] 이상적인 실험 ###

무작위 통제 실험은 인과효과를 파악하는 가장 신뢰할 수 있고 간단한 방법이다. 

다만, 주제에 따라 RCT는 많은 시간과 비용이 들거나 비윤리적일 수 있다. 

하지만 무작위 실험을 단순히 인과관계를 밝히는 도구 이상으로, 오히려 벤치마크로 활용하는 것이 목표다. 


### [2.4] 가장 위험한 수식 ###

표준오차(standard error) -> 생략


### [2.5] 추정값의 표준오차 ###

판다스에서는 std 메서드와 표준오차를 계산하는 메서드인 .sem()을 통해 표준 오차를 구할 수 있다

!['img32'](asssets/img/CI_week1/img32.png)


### [2.6] 신뢰구간 ###

베르누이 분포, 신뢰구간, CLT, 표준정규분포

```python
x = np.linspace(-4, 4, 100)
y = stats.norm.pdf(x, 0, 1)

plt.figure(figsize=(10,4))
plt.plot(x, y, linestyle="solid")
plt.fill_between(x.clip(-3, +3), 0, y, alpha=0.5, label="~99.7% mass", color="C2")
plt.fill_between(x.clip(-2, +2), 0, y, alpha=0.5, label="~95% mass", color="C1")
plt.fill_between(x.clip(-1, +1), 0, y, alpha=0.5, label="~68% mass", color="C0")
plt.ylabel("Density")
plt.legend()
```
!['img33'](asssets/img/CI_week1/img33.png)

```python
exp_se = short_email.sem()
exp_mu = short_email.mean()
ci = (exp_mu - 2 * exp_se, exp_mu + 2 * exp_se)
print("95% CI for Short Email: ", ci)

# 95% CI for Short Email:  (0.06436609374091676, 0.18563390625908324)


x = np.linspace(exp_mu - 4*exp_se, exp_mu + 4*exp_se, 100)
y = stats.norm.pdf(x, exp_mu, exp_se)

plt.figure(figsize=(10,4))
plt.plot(x, y, lw=3)
plt.vlines(ci[1], ymin=0, ymax=4, ls="dotted")
plt.vlines(ci[0], ymin=0, ymax=4, ls="dotted", label="95% CI")
plt.xlabel("Conversion")
plt.legend()
```
!['img34'](asssets/img/CI_week1/img34.png)


이번엔 99% 신뢰구간을 찾아보자. 
scipy의 ppf 함수를 사용하면 표준정규분포의 CDF의 역함수를 반환한다. 
예를 들어 ppf(0.5)=0 이라면 표준정규분포의 질량 중 50%가 0미만에 위치한다는 뜻이다. 
따라서 1-@의 신뢰구간을 얻으려면 표준오차에 |ppf(@/2)|를 곱해야 한다.

```python
from scipy import stats

z = np.abs(stats.norm.ppf((1-.99)/2))
print(z)
ci = (exp_mu - z * exp_se, exp_mu + z * exp_se)
ci

# 2.5758293035489004
# (0.04690870373460816, 0.20309129626539185)


stats.norm.ppf((1-.99)/2)

# -2.5758293035489004


x = np.linspace(exp_mu - 4*exp_se, exp_mu + 4*exp_se, 100)
y = stats.norm.pdf(x, exp_mu, exp_se)

plt.figure(figsize=(10,4))
plt.plot(x, y, lw=3)
plt.vlines(ci[1], ymin=0, ymax=4, ls="dotted")
plt.vlines(ci[0], ymin=0, ymax=4, ls="dotted", label="99% CI")


ci_95 = (exp_mu - 1.96 * exp_se, exp_mu + 1.96 * exp_se)

plt.vlines(ci_95[1], ymin=0, ymax=4, ls="dashed")
plt.vlines(ci_95[0], ymin=0, ymax=4, ls="dashed", label="95% CI")
plt.xlabel("Conversion")
plt.legend()
```
!['img35'](asssets/img/CI_week1/img35.png)


```python
def ci(y: pd.Series):
    return (y.mean() - 2 * y.sem(), y.mean() + 2 * y.sem())

print("95% CI for Short Email:", ci(short_email))
print("95% CI for Long Email:", ci(long_email))
print("95% CI for No Email:", ci(no_email))

# 95% CI for Short Email: (0.06436609374091676, 0.18563390625908324)
# 95% CI for Long Email: (0.01115382234126202, 0.09893792077800403)
# 95% CI for No Email: (0.0006919679286838468, 0.08441441505003955)


plt.figure(figsize=(10,4))

x = np.linspace(-0.05, .25, 100)
short_dist = stats.norm.pdf(x, short_email.mean(), short_email.sem())
plt.plot(x, short_dist, lw=2, label="Short", linestyle=linestyle[0])
plt.fill_between(x.clip(ci(short_email)[0], ci(short_email)[1]), 0, short_dist, alpha=0.2, color="0.0")

long_dist = stats.norm.pdf(x, long_email.mean(), long_email.sem())
plt.plot(x, long_dist, lw=2, label="Long", linestyle=linestyle[1])
plt.fill_between(x.clip(ci(long_email)[0], ci(long_email)[1]), 0, long_dist, alpha=0.2, color="0.4")

no_email_dist = stats.norm.pdf(x, no_email.mean(), no_email.sem())
plt.plot(x, no_email_dist, lw=2, label="No email", linestyle=linestyle[2])
plt.fill_between(x.clip(ci(no_email)[0], ci(no_email)[1]), 0, no_email_dist, alpha=0.2, color="0.8")

plt.xlabel("Conversion")
plt.legend()
```
!['img36'](asssets/img/CI_week1/img36.png)

여기서 세 그룹의 95% 신뢰구간이 서로 겹치는 것을 볼 수 있다. 
만약 이 구간들이 겹치지 않았다면, 그룹 간의 전환율 차이가 단지 우연이 아닐 가능성이 높다고 볼 수 있을 것이다. 
즉, 교차 판매 이메일 발송이 전환율에 통계적으로 유의한 영향을 미쳤다. 

그러나 실제로는 신뢰구간이 겹치기에 이런 결론을 내릴 수 없다. 
하지만 그렇다고 통계적으로 유의하지 않다고 단정할 수는 없다. 

> 요약: 신뢰구간은 추정값에 대해 불확실성을 나타내는 방법이다. 표본 크기가 작을 수록 표준오차가 커지고, 그 결과 신뢰구간도 넓어진다. 신뢰구간은 계산하기 매우 쉬우므로 신뢰구간을 제시하지 않는다면 불순한 의도나 지식 부족을 의미할 수 있다. 마지막으로, 불확실성 지표가 없는 측정값에 대해서는 항상 의심할 필요가 있다. 

**신뢰구간의 %는 신뢰구간을 계산하는데 사용한 알고리즘의 신뢰도이지, 특정 구간 자체의 신뢰도가 아니다.**

다만, 이 책의 저자는 (엄밀히는 틀렸지만) 신뢰구간이 95%확률로 실제 평균을 포함한다고 해도 크게 문제될 것이 없다고 한다. 


### [2.7] 가설검정 ###

!['img37'](asssets/img/CI_week1/img37.png)

```python
import seaborn as sns
from matplotlib import pyplot as plt

np.random.seed(123)

n1 = np.random.normal(4, 3, 30000)
n2 = np.random.normal(1, 4, 30000)
n_diff = n2 - n1

plt.figure(figsize=(10,4))
sns.distplot(n1, hist=False, label="$N(4,3^2)$", color="0.0", kde_kws={"linestyle":linestyle[0]})
sns.distplot(n2, hist=False, label="$N(1,4^2)$", color="0.4", kde_kws={"linestyle":linestyle[1]})
sns.distplot(n_diff, hist=False,
             label=f"$N(-3, 5^2) = N(1,4^2) - (4,3^2)$", color="0.8", kde_kws={"linestyle":linestyle[1]})
plt.legend();
```
!['img38'](asssets/img/CI_week1/img38.png)


#### [2.7.1] 귀무가설 ####

!['img39'](asssets/img/CI_week1/img39.png)


#### [2.7.2] 검정통계량 ####

신뢰구간 외에도, 검정통계량(test statistic)을 사용하여 귀무가설을 기각하는 것이 유용할 수 있다. 
가장 많이 사용되는 검정통계량 중 하나는 t-statistic이다. 

!['img40'](asssets/img/CI_week1/img40.png)


### [2.8] p값 ###

**p값은 귀무가설이 참이라고 가정할 때 관측된 결과보다 더 극단적인 결과가 실제로 관측될 확률이다.**

**여기서 p값은 P(H_0|data)가 아니라 P(data|H_0)다.**

단측/양측 귀무가설


### [2.9] 검정력 ###

- 검정력: 귀무가설을 올바르게 기각할 확률

검정력은 실험에 필요한 표본 크기를 파악할 때뿐만 아니라, 제대로 실행하지 않은 실험에서 문제를 발견할 때도 유용하다. 





### [2.10] 표본 크기 계산 ###




